# Native functions library example

The approach used in the design of native (C/C++) binding here is to minimize the amount of manual work required, and as a result, the number of potential bugs.

The idea is that the imported functions are static functions in a class, which can either be defined within the header, or implemented in a cpp file.
A python script is then used which scans the code and automatically generates / updates the binding code.
In this example, the header contains the following:

```aiignore
//BIND
class Sample
{
public:
	static void Print(int value);
};
```

and the cpp file contains the required implementation:

```aiignore
void Sample::Print(int a)
{
	std::cout << a << std::endl;
}
```

Then the python script adds the following block of code that completes the wrapper functions.
```aiignore
//////////////////////////////////////////////////
//AUTOGENERATED CODE - DO NOT EDIT

void sample_Sample_Print_wrapper(WrenVM* vm)
{
	int value = static_cast<int>(wrenGetSlotDouble(vm, 1));
	Sample::Print(value);
}


void sample_Sample_Binder()
{
	Singleton<ForeignFunctions>::Instance().bind("sample.Sample.Print(_)", sample_Sample_Print_wrapper);
	const char* module_code=R"(
class Sample {
	foreign static Print(value)
}
)";
	Singleton<ForeignFunctions>::Instance().set_module_code("sample", module_code);
}
```

This entire code is then compiled into a (DLL | so) file.

The debugger will scan the directory in which it's running and try to load all matching shared libraries, and do all the needed mapping so that the wren code can then use a simple:
```aiignore
import "sample" for Sample

Sample.Print("hello")
```