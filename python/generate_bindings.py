from typing import List
import argh
import os
import re

all_initializers=[]
class_pattern = r'class (\w+)'
argument_pattern = r'(int|const char\*|const Bytes\&) (\w+)'
multi_argument_pattern = argument_pattern + r'(, '+argument_pattern+')*'
func_pattern = r'static (\w+) (\w+)\(([^)]*)\);'
type_slot_mapping={
    'int': 'Double',
    'double': 'Double',
    'const char*': 'String',
    'bool': 'Bool',
    'const Bytes&': 'Bytes'
}

def type_to_slot(name: str)->str:
    if name in type_slot_mapping:
        return type_slot_mapping[name]
    raise RuntimeError(f'Unknown type {name}')

def process_class(header_path: str, module_name: str, class_lines: List[str]):
    impl_path = header_path.replace('.h', '.cpp')
    impl_lines=[]
    header_comment = '//AUTOGENERATED CODE - DO NOT EDIT'
    with open(impl_path) as f:
        impl_lines = f.readlines()
    for i in range(len(impl_lines)):
        if impl_lines[i].startswith(header_comment):
            impl_lines = impl_lines[0:i]
            break
    f = open(impl_path, 'w')
    for line in impl_lines:
        f.write(line)
    f.write(f'{header_comment}\n')
    m = re.match(class_pattern, class_lines[0])
    if not m:
        return
    class_name = m.group(1)
    func_mapping = {}
    code = []
    for line in class_lines[1:]:
        m = re.match(func_pattern, line)
        if m:
            g = m.groups()
            # return_type = g[0]
            func_name = g[1]
            arguments = [s for s in g[2].split(',') if s]
            prototype=f'{func_name}(' + ','.join(['_']*len(arguments)) + ')'
            key = f'{module_name}.{class_name}.{prototype}'
            wrapper_name = f'{module_name}_{class_name}_{func_name}_wrapper'
            func_mapping[key] = wrapper_name
            f.write(f'\nvoid {wrapper_name}(WrenVM* vm)\n{{\n')
            arg_names=[]
            if len(arguments) > 0:
                index=1
                for argument in arguments:
                    argument = argument.strip().rsplit(' ', 1)
                    arg_type = argument[0]
                    arg_name = argument[1]
                    arg_names.append(arg_name)
                    if arg_type=='const Bytes&':
                        f.write(f'\tBytes {arg_name};\n')
                        f.write(f'\t{arg_name}.data = wrenGetSlotBytes(vm, {index}, &{arg_name}.length);\n')
                    else:
                        casting_prefix=''
                        castfix_suffix=''
                        if arg_type=='int':
                            casting_prefix='static_cast<int>('
                            castfix_suffix=')'
                        f.write(f'\t{arg_type} {arg_name} = {casting_prefix}wrenGetSlot{type_to_slot(arg_type)}(vm, {index}){castfix_suffix};\n')
                    index+=1
            code_line=f'\tforeign static {func_name}({', '.join(arg_names)})'
            code.append(code_line)
            f.write(f'\t{class_name}::{func_name}({','.join(arg_names)});\n')
            f.write('}\n')
    binder_name =f'{module_name}_{class_name}_Binder'
    f.write(f'\n\nvoid {binder_name}()\n{{\n')
    for key in func_mapping:
        f.write(f'\tSingleton<ForeignFunctions>::Instance().bind("{key}", {func_mapping[key]});\n')
    f.write(f'\tconst char* module_code=R"(\n')
    f.write(f'class {class_name} {{\n')
    for code_line in code:
        f.write(f'{code_line}\n')
    f.write('}\n')
    f.write(f')";\n')
    f.write(f'\tSingleton<ForeignFunctions>::Instance().set_module_code("{module_name}", module_code);\n')
    f.write(f'}}\n\n')
    all_initializers.append(f'{binder_name}')

def main(folder: str):
    headers = [f for f in os.listdir(folder) if f.endswith('.h')]
    for filename in headers:
        filepath = os.path.join(folder, filename)
        file = os.path.basename(filepath)
        module_name = file.replace('.h', '')
        active=False
        lines = open(filepath, 'r').readlines()
        class_lines=[]
        for line in lines:
            if active and line.startswith('};'):
                active=False
                process_class(filepath, module_name, class_lines)
                class_lines=[]
            if line.startswith('//BIND'):
                active=True
            elif active:
                class_lines.append(line.strip())
    with open(os.path.join(folder,'initializers.h'),'w') as f:
        f.write('#pragma once\n\n')
        f.write('void initialize_bindings()\n{\n')
        for name in all_initializers:
            f.write(f'\tvoid {name}();\n\t{name}();\n')
        f.write('}\n\n')

if __name__ == '__main__':
    argh.dispatch_command(main)